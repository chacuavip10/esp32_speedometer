/**
 * ESP32 + SSD1306 + u-blox NAV‑PVT Speedometer (PlatformIO / Arduino)
 * Dual-core + dual-snapshot design WITH:
 *   - Auto-baud detect (UBX or NMEA) on GPS UART2
 *   - UBX configuration sender (disable NMEA, enable NAV-PVT, 10 Hz, automotive model, set 115200 baud)
 *   - Core 1 (gps_task): UART2 read, NMEA prefilter, UBX framer, update REALTIME snapshot on every PVT,
 *                        and publish COUNTER snapshot every 1s.
 *   - Core 0 (ui_task):  Reads REALTIME snapshot frequently for smooth UI (<=100ms), measures redraw_us,
 *                        and reads COUNTER snapshot (1Hz) only for debug prints.
 *
 * Optimizations kept:
 *   - UART2 RX buffer 2048B, UBX framer buffer 2048B
 *   - OLED redraw only on content change OR >= 100 ms
 *   - Keep float thresholds for sAcc vs gSpeed (per user request)
 *   - Disable WiFi/Bluetooth & free memory in setup()
 *   - Force CPU 240 MHz at runtime (also set in platformio.ini)
 */

#include <Arduino.h>
#include <Wire.h>
#include <HardwareSerial.h>
#include <Adafruit_SSD1306.h>
#include <WiFi.h>
#include "esp_wifi.h"
#include "esp_bt.h"
#include "esp_bt_main.h"

#define DEBUG_PROFILE 1
#define DEBUG_CPU 1 // 1 = bật đo CPU/RAM, 0 = tắt

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
#define SCREEN_ADDRESS 0x3C

// -------------------- Pins --------------------
static const uint8_t PIN_RXD2 = 16; // GPS TX -> RXD2
static const uint8_t PIN_TXD2 = 17; // GPS RX -> TXD2
static const int PIN_BUTTON = 32;

static int coreIdGps = -1;
static int coreIdUi = -1;

// DEBUG CPU MEMORY
#if DEBUG_CPU
#include "esp_freertos_hooks.h"
#include "esp_timer.h"
static volatile uint32_t s_idleCnt[2] = {0, 0};
static uint32_t s_idleCntLast[2] = {0, 0};
static uint32_t s_idleBaseline[2] = {0, 0};

static bool idle_hook_core0(void)
{
  s_idleCnt[0]++;
  return true;
}
static bool idle_hook_core1(void)
{
  s_idleCnt[1]++;
  return true;
}

// static uint32_t s_uptimeSec = 0;
static void computeCpuLoad1s(float outLoad[2])
{
  static uint32_t warmup = 2;  // khóa baseline sau 2s
  static float decay = 0.001f; // 0.1%/s, giúp baseline dần “thoáng” ra

  uint32_t d0 = s_idleCnt[0] - s_idleCntLast[0];
  uint32_t d1 = s_idleCnt[1] - s_idleCntLast[1];
  s_idleCntLast[0] = s_idleCnt[0];
  s_idleCntLast[1] = s_idleCnt[1];

  // Học baseline trong warmup
  if (warmup)
  {
    if (d0 > s_idleBaseline[0])
      s_idleBaseline[0] = d0;
    if (d1 > s_idleBaseline[1])
      s_idleBaseline[1] = d1;
    if (--warmup == 0)
    { // khóa baseline
      if (!s_idleBaseline[0])
        s_idleBaseline[0] = d0 ? d0 : 1;
      if (!s_idleBaseline[1])
        s_idleBaseline[1] = d1 ? d1 : 1;
    }
  }
  else
  {
    // sau warmup: baseline = max(baseline*(1-decay), d)
    s_idleBaseline[0] = (uint32_t)max((float)s_idleBaseline[0] * (1.0f - decay), (float)d0);
    s_idleBaseline[1] = (uint32_t)max((float)s_idleBaseline[1] * (1.0f - decay), (float)d1);
  }

  float l0 = 1.0f - (float)d0 / (float)(s_idleBaseline[0] ? s_idleBaseline[0] : 1);
  float l1 = 1.0f - (float)d1 / (float)(s_idleBaseline[1] ? s_idleBaseline[1] : 1);
  if (l0 < 0)
    l0 = 0;
  if (l0 > 1)
    l0 = 1;
  if (l1 < 0)
    l1 = 0;
  if (l1 > 1)
    l1 = 1;
  outLoad[0] = l0 * 100.0f;
  outLoad[1] = l1 * 100.0f;

  // s_uptimeSec++;
}

static void getMemoryUsage(float &heapPct, float &psramPct, bool &hasPsram)
{
  uint32_t heapTotal = ESP.getHeapSize();
  uint32_t heapFree = ESP.getFreeHeap();
  heapPct = heapTotal ? (100.0f * (float)(heapTotal - heapFree) / (float)heapTotal) : 0.0f;
  hasPsram = psramFound();
  if (hasPsram)
  {
    uint32_t psTotal = ESP.getPsramSize();
    uint32_t psFree = ESP.getFreePsram();
    psramPct = psTotal ? (100.0f * (float)(psTotal - psFree) / (float)psTotal) : 0.0f;
  }
  else
  {
    psramPct = 0.0f;
  }
}
#endif

// =============== Satellite icon ===============
#define sat_logo_HEIGHT 20
#define sat_logo_WIDTH 20
static const uint8_t sat_logo[] PROGMEM = {
    0x00, 0x01, 0x00, 0x80, 0x07, 0x00, 0xC0, 0x06, 0x00, 0x60, 0x30, 0x00,
    0x60, 0x78, 0x00, 0xC0, 0xFC, 0x00, 0x00, 0xFE, 0x01, 0x00, 0xFF, 0x01,
    0x80, 0xFF, 0x00, 0xC0, 0x7F, 0x06, 0xC0, 0x3F, 0x06, 0x80, 0x1F, 0x0C,
    0x80, 0x4F, 0x06, 0x19, 0xC6, 0x03, 0x1B, 0x80, 0x01, 0x73, 0x00, 0x00,
    0x66, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x70, 0x00, 0x00};

// Desired GPS baud after configuration
static const uint32_t TARGET_BAUD = 115200;

// -------------------- HW instances --------------------
HardwareSerial GPS(2);
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// -------------------- Helpers for autodetect --------------------
static int COMMON_BAUD_RATE[] = {38400, 115200, 230400, 460800, 9600};

static bool readByteWithTimeout(HardwareSerial &s, uint8_t &b, uint32_t ms)
{
  uint32_t t0 = millis();
  while (millis() - t0 < ms)
  {
    if (s.available())
    {
      b = s.read();
      return true;
    }
    yield();
  }
  return false;
}
static bool syncToUBX(HardwareSerial &s, uint32_t ms)
{
  enum
  {
    WAIT_B5,
    WAIT_62
  } st = WAIT_B5;
  uint32_t t0 = millis();
  while (millis() - t0 < ms)
  {
    if (!s.available())
    {
      yield();
      continue;
    }
    uint8_t b = s.read();
    if (st == WAIT_B5)
      st = (b == 0xB5) ? WAIT_62 : WAIT_B5;
    else
    {
      if (b == 0x62)
        return true;
      st = (b == 0xB5) ? WAIT_62 : WAIT_B5;
    }
  }
  return false;
}
static bool readUBXValid(HardwareSerial &s, uint8_t &cls, uint8_t &id, uint16_t &len, uint32_t firstSyncTimeoutMs = 600)
{
  if (!syncToUBX(s, firstSyncTimeoutMs))
    return false;
  uint8_t lenL, lenH, b;
  uint8_t ckA = 0, ckB = 0;
  auto upd = [&](uint8_t v)
  { ckA+=v; ckB+=ckA; };
  if (!readByteWithTimeout(s, cls, 150))
    return false;
  upd(cls);
  if (!readByteWithTimeout(s, id, 150))
    return false;
  upd(id);
  if (!readByteWithTimeout(s, lenL, 150))
    return false;
  upd(lenL);
  if (!readByteWithTimeout(s, lenH, 150))
    return false;
  upd(lenH);
  len = (uint16_t)lenL | ((uint16_t)lenH << 8);
  for (uint16_t i = 0; i < len; i++)
  {
    if (!readByteWithTimeout(s, b, 200))
      return false;
    upd(b);
  }
  uint8_t inA, inB;
  if (!readByteWithTimeout(s, inA, 150))
    return false;
  if (!readByteWithTimeout(s, inB, 150))
    return false;
  return (ckA == inA) && (ckB == inB);
}
static uint8_t hex2nibble(char c)
{
  if (c >= '0' && c <= '9')
    return c - '0';
  if (c >= 'A' && c <= 'F')
    return c - 'A' + 10;
  if (c >= 'a' && c <= 'f')
    return c - 'a' + 10;
  return 0xFF;
}

// --- NMEA helpers ---
// Compute XOR of all chars between '$' and '*'
static inline uint8_t nmeaChecksumBody(const String &body)
{
  uint8_t cs = 0;
  for (size_t i = 0; i < body.length(); ++i)
    cs ^= (uint8_t)body[i];
  return cs;
}

// Parse two hex chars to a byte; return false if invalid
static inline bool nmeaParseHexByte(char h1, char h2, uint8_t &out)
{
  uint8_t hi = hex2nibble(h1), lo = hex2nibble(h2);
  if (hi == 0xFF || lo == 0xFF)
    return false;
  out = (uint8_t)((hi << 4) | lo);
  return true;
}

static bool readNMEAValid(HardwareSerial &s, String &head, uint32_t timeoutMs = 1200)
{
  uint32_t t0 = millis();
  while (millis() - t0 < timeoutMs)
  {
    if (!s.available())
    {
      yield();
      continue;
    }

    // Seek to '$'
    char c = s.read();
    if (c != '$')
      continue;

    String body; // everything between '$' and '*'
    uint32_t tBody = millis();

    // Collect body until '*' (or line end)
    while (millis() - tBody < 900)
    {
      if (!s.available())
      {
        yield();
        continue;
      }
      char d = s.read();
      if (d == '*')
      {
        // Read two hex chars of checksum
        char h1 = 0, h2 = 0;
        uint32_t tw = millis();
        while (millis() - tw < 200 && !s.available())
          yield();
        if (!s.available())
          break;
        h1 = s.read();
        tw = millis();
        while (millis() - tw < 200 && !s.available())
          yield();
        if (!s.available())
          break;
        h2 = s.read();

        uint8_t want = 0;
        if (!nmeaParseHexByte(h1, h2, want))
          break;

        // Eat to end-of-line
        while (s.available())
        {
          char e = s.read();
          if (e == '\n')
            break;
        }

        // Validate checksum
        uint8_t got = nmeaChecksumBody(body);
        if (got == want)
        {
          int comma = body.indexOf(',');
          head = (comma > 0) ? body.substring(0, comma) : body;
          return true;
        }
        break; // checksum mismatch → try again
      }
      if (d == '\r' || d == '\n')
        break;   // malformed (no '*')
      body += d; // NOTE: '$' not included, per NMEA
    }
  }
  return false;
}

static int detectGPSBaudrateWithStatus()
{
  const int n = sizeof(COMMON_BAUD_RATE) / sizeof(COMMON_BAUD_RATE[0]);
  for (int i = 0; i < n; i++)
  {
    int br = COMMON_BAUD_RATE[i];
    Serial.printf("[SETUP] Trying %d...\n", br);
    GPS.begin(br, SERIAL_8N1, PIN_RXD2, PIN_TXD2);
    GPS.flush();
    delay(60);
    uint32_t window = 1600;
    uint32_t t0 = millis();
    while (millis() - t0 < window)
    {
      uint8_t ucls = 0, uid = 0;
      uint16_t ulen = 0;
      if (readUBXValid(GPS, ucls, uid, ulen, 250))
      {
        Serial.printf("  UBX OK @ %d | cls=0x%02X id=0x%02X len=%u\n", br, ucls, uid, ulen);
        GPS.flush();
        return br;
      }
      String head;
      if (readNMEAValid(GPS, head, 300))
      {
        Serial.printf("  NMEA OK @ %d | %s\n", br, head.c_str());
        GPS.flush();
        return br;
      }
    }
    GPS.end();
    delay(100);
    Serial.printf("  No valid frame @ %d\n", br);
  }
  return -1;
}

// -------------------- UBX command blobs (precomputed) --------------------
#include <pgmspace.h>
#define PROGMEM_READ_U8(p, i) (uint8_t)pgm_read_byte(((const uint8_t *)(p)) + (i))
// NMEA msg
static const uint8_t NMEA_ID_GGA_I2C_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xBA, 0x00, 0x91, 0x20, 0x00, 0x05, 0xC6};
static const uint8_t NMEA_ID_GGA_SPI_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xBE, 0x00, 0x91, 0x20, 0x00, 0x09, 0xDA};
static const uint8_t NMEA_ID_GGA_UART1_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xBB, 0x00, 0x91, 0x20, 0x00, 0x06, 0xCB};
static const uint8_t NMEA_ID_GLL_I2C_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xC9, 0x00, 0x91, 0x20, 0x00, 0x14, 0x11};
static const uint8_t NMEA_ID_GLL_SPI_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCD, 0x00, 0x91, 0x20, 0x00, 0x18, 0x25};
static const uint8_t NMEA_ID_GLL_UART1_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCA, 0x00, 0x91, 0x20, 0x00, 0x15, 0x16};
static const uint8_t NMEA_ID_GSA_I2C_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xBF, 0x00, 0x91, 0x20, 0x00, 0x0A, 0xDF};
static const uint8_t NMEA_ID_GSA_SPI_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xC3, 0x00, 0x91, 0x20, 0x00, 0x0E, 0xF3};
static const uint8_t NMEA_ID_GSA_UART1_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xC0, 0x00, 0x91, 0x20, 0x00, 0x0B, 0xE4};
static const uint8_t NMEA_ID_GSV_I2C_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xC4, 0x00, 0x91, 0x20, 0x00, 0x0F, 0xF8};
static const uint8_t NMEA_ID_GSV_SPI_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xC8, 0x00, 0x91, 0x20, 0x00, 0x13, 0x0C};
static const uint8_t NMEA_ID_GSV_UART1_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xC5, 0x00, 0x91, 0x20, 0x00, 0x10, 0xFD};
static const uint8_t NMEA_ID_RMC_I2C_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xAB, 0x00, 0x91, 0x20, 0x00, 0xF6, 0x7B};
static const uint8_t NMEA_ID_RMC_SPI_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xAF, 0x00, 0x91, 0x20, 0x00, 0xFA, 0x8F};
static const uint8_t NMEA_ID_RMC_UART1_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xAC, 0x00, 0x91, 0x20, 0x00, 0xF7, 0x80};
static const uint8_t NMEA_ID_VTG_I2C_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xB0, 0x00, 0x91, 0x20, 0x00, 0xFB, 0x94};
static const uint8_t NMEA_ID_VTG_SPI_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xB4, 0x00, 0x91, 0x20, 0x00, 0xFF, 0xA8};
static const uint8_t NMEA_ID_VTG_UART1_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0xB1, 0x00, 0x91, 0x20, 0x00, 0xFC, 0x99};
// UBX mgs
static const uint8_t UBX_NAV_PVT_UART1_ON[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x07, 0x00, 0x91, 0x20, 0x01, 0x53, 0x48};
// Rate
static const uint8_t CFG_RATE_MEAS_10Hz[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x0A, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x21, 0x30, 0x64, 0x00, 0x51, 0xB9};
// Dyn model
static const uint8_t CFG_NAVSPG_DYNMODEL_AUTOMOTIVE[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x21, 0x00, 0x11, 0x20, 0x04, 0xF0, 0x4D};
// GNSS
static const uint8_t GPS_ENA[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1F, 0x00, 0x31, 0x10, 0x01, 0xFB, 0x80};
static const uint8_t GPS_L1CA_ENA[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x31, 0x10, 0x01, 0xDD, 0xEA};

static const uint8_t SBAS_ENA[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x31, 0x10, 0x01, 0xFC, 0x85};
static const uint8_t SBAS_L1CA_ENA[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x05, 0x00, 0x31, 0x10, 0x01, 0xE1, 0xFE};

static const uint8_t BDS_ENA[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x22, 0x00, 0x31, 0x10, 0x01, 0xFE, 0x8F};
static const uint8_t BDS_B1_ENA[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0D, 0x00, 0x31, 0x10, 0x01, 0xE9, 0x26};
static const uint8_t BDS_B1_ENA_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0D, 0x00, 0x31, 0x10, 0x00, 0xE8, 0x25}; // BEIDOU B1I OFF
static const uint8_t BDS_B1C_ENA[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0F, 0x00, 0x31, 0x10, 0x01, 0xEB, 0x30};    // BEIDOU B1C ON, same frequency as GPS L1 -> same antenna
static const uint8_t BDS_B1C_ENA_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0F, 0x00, 0x31, 0x10, 0x00, 0xEA, 0x2F};

static const uint8_t QZSS_ENA[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x24, 0x00, 0x31, 0x10, 0x01, 0x00, 0x99};
static const uint8_t QZSS_L1CA_ENA[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x12, 0x00, 0x31, 0x10, 0x01, 0xEE, 0x3F};
static const uint8_t QZSS_L1S_ENA[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x14, 0x00, 0x31, 0x10, 0x01, 0xF0, 0x49};

static const uint8_t GLO_ENA_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x25, 0x00, 0x31, 0x10, 0x00, 0x00, 0x9D};

static const uint8_t GAL_ENA_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x21, 0x00, 0x31, 0x10, 0x00, 0xFC, 0x89};
static const uint8_t GAL_E1_ENA_OFF[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x09, 0x00, 0x00, 0x01, 0x00, 0x00, 0x07, 0x00, 0x31, 0x10, 0x00, 0xE2, 0x07};

// UART RATE
static const uint8_t CFG_UART1_BAUDRATE_115200[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x52, 0x40, 0x00, 0xC2, 0x01, 0x00, 0xF3, 0xA5};
static const uint8_t CFG_UART1_BAUDRATE_230400[] PROGMEM = {0xB5, 0x62, 0x06, 0x8A, 0x0C, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x52, 0x40, 0x00, 0x84, 0x03, 0x00, 0xB7, 0xEF};

// UBX send helpers
static void sendUbx(const uint8_t *cmd)
{
  const uint8_t len = PROGMEM_READ_U8(cmd, 4) | (PROGMEM_READ_U8(cmd, 5) << 8);
  const uint16_t total = 6 + len + 2;
  static uint8_t buf[128];
  if (total > sizeof(buf))
    return;
  for (uint16_t i = 0; i < total; i++)
    buf[i] = PROGMEM_READ_U8(cmd, i);
  GPS.write(buf, total);
  GPS.flush();
}
static void calcUbxChecksum(const uint8_t *data, uint16_t len, uint8_t &ckA, uint8_t &ckB)
{
  ckA = 0;
  ckB = 0;
  for (uint16_t i = 0; i < len; i++)
  {
    ckA += data[i];
    ckB += ckA;
  }
}
static bool sendUbxWithAck(const uint8_t *cmd, uint8_t expectCls, uint8_t expectId, uint16_t timeoutMs)
{
  sendUbx(cmd);
  delay(10);
  enum
  {
    SY1,
    SY2,
    CLASS,
    ID,
    LENL,
    LENH,
    PAY0,
    PAY1,
    CKA,
    CKB
  } st = SY1;
  uint8_t t[10];
  uint32_t start = millis();
  while (millis() - start < timeoutMs)
  {
    if (!GPS.available())
    {
      delay(1);
      continue;
    }
    uint8_t b = GPS.read();
    switch (st)
    {
    case SY1:
      st = (b == 0xB5) ? SY2 : SY1;
      break;
    case SY2:
      st = (b == 0x62) ? CLASS : SY1;
      break;
    case CLASS:
      t[2] = b;
      st = (b == 0x05) ? ID : SY1;
      break;
    case ID:
      t[3] = b;
      st = LENL;
      break;
    case LENL:
      t[4] = b;
      st = LENH;
      break;
    case LENH:
      t[5] = b;
      st = ((((uint16_t)t[4]) | ((uint16_t)b << 8)) == 2) ? PAY0 : SY1;
      break;
    case PAY0:
      t[6] = b;
      st = PAY1;
      break;
    case PAY1:
      t[7] = b;
      st = CKA;
      break;
    case CKA:
      t[8] = b;
      st = CKB;
      break;
    case CKB:
    {
      t[9] = b;
      uint8_t ckA, ckB;
      uint8_t sum[6] = {0x05, t[3], t[4], t[5], t[6], t[7]};
      calcUbxChecksum(sum, 6, ckA, ckB);
      if (ckA == t[8] && ckB == t[9])
      {
        uint8_t ackType = t[3]; // 0x01=ACK
        if (t[6] == expectCls && t[7] == expectId)
          return (ackType == 0x01);
      }
      st = SY1;
    }
    break;
    }
  }
  Serial.println(F("[UBX][ACK] Timeout"));
  return false;
}

// -------------------- UBX NAV-PVT struct --------------------
#pragma pack(push, 1)
struct UbxNavPvt
{
  uint32_t iTOW;
  uint16_t year;
  uint8_t month, day, hour, minute, second, valid;
  uint32_t tAcc;
  int32_t nano;
  uint8_t fixType, flags, flags2, numSV;
  int32_t lon, lat, height, hMSL;
  uint32_t hAcc, vAcc;
  int32_t velN, velE, velD, gSpeed; // mm/s
  int32_t headMot;
  uint32_t sAcc;
  uint32_t headAcc;
  uint16_t pDOP;
  uint8_t reserved1[6];
  int32_t headVeh;
  int16_t magDec;
  uint16_t magAcc;
};
#pragma pack(pop)

// -------------------- UBX framer --------------------
static const uint8_t UBX_SYNC1 = 0xB5;
static const uint8_t UBX_SYNC2 = 0x62;
static const uint16_t UBX_FRAMER_BUF = 2048;

struct UbxFrame
{
  uint8_t cls = 0, id = 0;
  uint16_t len = 0;
  const uint8_t *payload = nullptr;
};

class UbxFramer
{
public:
  UbxFramer() { reset(); }
  bool poll(Stream &s, UbxFrame &out)
  {
    while (s.available())
    {
      uint8_t c = s.read();
      if (step(c, out))
        return true;
    }
    return false;
  }
  bool feed(uint8_t c, UbxFrame &out)
  {
    return step(c, out);
  }
  void reset()
  {
    st_ = 0;
    payIdx_ = 0;
    payloadLen_ = 0;
    ckA_ = ckB_ = 0;
  }

private:
  uint8_t st_ = 0, cls_ = 0, id_ = 0;
  uint16_t payloadLen_ = 0, payIdx_ = 0;
  uint8_t ckA_ = 0, ckB_ = 0;
  uint8_t buf_[UBX_FRAMER_BUF];
  static inline void ckAdd(uint8_t b, uint8_t &A, uint8_t &B)
  {
    A += b;
    B += A;
  }
  bool step(uint8_t c, UbxFrame &out)
  {
    switch (st_)
    {
    case 0:
      if (c == UBX_SYNC1)
        st_ = 1;
      return false;
    case 1:
      if (c == UBX_SYNC2)
        st_ = 2;
      else
        st_ = 0;
      return false;
    case 2:
      cls_ = c;
      ckA_ = c;
      ckB_ = ckA_;
      st_ = 3;
      return false;
    case 3:
      id_ = c;
      ckAdd(c, ckA_, ckB_);
      st_ = 4;
      return false;
    case 4:
      payloadLen_ = c;
      ckAdd(c, ckA_, ckB_);
      st_ = 5;
      return false;
    case 5:
      payloadLen_ |= ((uint16_t)c << 8);
      ckAdd(c, ckA_, ckB_);
      if (payloadLen_ > (UBX_FRAMER_BUF - 2))
      {
        st_ = 0;
        return false;
      }
      payIdx_ = 0;
      st_ = (payloadLen_ == 0) ? 7 : 6;
      return false;
    case 6:
      buf_[payIdx_++] = c;
      ckAdd(c, ckA_, ckB_);
      if (payIdx_ == payloadLen_)
        st_ = 7;
      return false;
    case 7:
      if (c != ckA_)
      {
        st_ = 0;
        return false;
      }
      st_ = 8;
      return false;
    case 8:
      st_ = 0;
      if (c != ckB_)
        return false;
      out.cls = cls_;
      out.id = id_;
      out.len = payloadLen_;
      out.payload = buf_;
      return true;
    }
    return false;
  }
};
static UbxFramer FR;

// -------------------- NMEA prefilter (skip+count) --------------------
static inline void nmeaPrefilterPoll(Stream &s, uint16_t *nmeaValidPerSec, int budgetBytes = 96)
{
  enum State
  {
    IDLE,
    BODY,
    STAR1,
    STAR2,
    EAT_EOL
  };
  static State st = IDLE;
  static uint8_t xsum = 0;
  static char h1 = 0, h2 = 0;

  int processed = 0;
  while (processed < budgetBytes && s.available())
  {
    char c = s.read();
    processed++;
    switch (st)
    {
    case IDLE:
      if (c == '$')
      {
        xsum = 0;
        st = BODY;
      }
      break;

    case BODY:
      if (c == '*')
      {
        st = STAR1;
      }
      else if (c == '\r' || c == '\n')
      {
        st = IDLE;
      } // invalid line; drop
      else
      {
        xsum ^= (uint8_t)c;
      }
      break;

    case STAR1:
      h1 = c;
      st = STAR2;
      break;

    case STAR2:
    {
      h2 = c;
      uint8_t hi = hex2nibble(h1), lo = hex2nibble(h2);
      if (hi != 0xFF && lo != 0xFF)
      {
        uint8_t want = (uint8_t)((hi << 4) | lo);
        if (nmeaValidPerSec && want == xsum)
          (*nmeaValidPerSec)++; // count only checksum‑valid sentences
      }
      st = EAT_EOL; // consume until LF
      break;
    }

    case EAT_EOL:
      if (c == '\n')
        st = IDLE;
      break;
    }
  }
}

// -------------------- Dual snapshots --------------------
struct RtSnapshot
{
  volatile uint32_t seq;
  UbxNavPvt pvt;
  bool gpsLost;
  uint32_t pvtVer; // NEW: tăng mỗi lần xử lý 1 bản tin NAV-PVT hợp lệ
};
struct CntSnapshot
{
  volatile uint32_t seq;
  uint16_t ubxPerSec, pvtSeenPerSec, pvtValidPerSec, nmeaPerSec;
};

static RtSnapshot g_rtSnap;
static CntSnapshot g_cntSnap;
static portMUX_TYPE g_rtMux = portMUX_INITIALIZER_UNLOCKED;
static portMUX_TYPE g_cntMux = portMUX_INITIALIZER_UNLOCKED;
static volatile uint32_t g_pvtVer = 0; // NEW: version/counter cho NAV-PVT

static inline void rt_write(const UbxNavPvt &p, bool lost, uint32_t ver)
{
  portENTER_CRITICAL(&g_rtMux);
  g_rtSnap.seq++;
  g_rtSnap.pvt = p;
  g_rtSnap.gpsLost = lost;
  g_rtSnap.pvtVer = ver; // NEW
  g_rtSnap.seq++;
  portEXIT_CRITICAL(&g_rtMux);
}
static inline void rt_read(RtSnapshot &out)
{
  uint32_t s1, s2;
  do
  {
    s1 = g_rtSnap.seq;
    if (s1 & 1)
      continue;
    out = g_rtSnap;
    s2 = g_rtSnap.seq;
  } while (s1 != s2 || (s2 & 1));
}
static inline void cnt_write(uint16_t ubx, uint16_t seen, uint16_t valid, uint16_t nmea)
{
  portENTER_CRITICAL(&g_cntMux);
  g_cntSnap.seq++;
  g_cntSnap.ubxPerSec = ubx;
  g_cntSnap.pvtSeenPerSec = seen;
  g_cntSnap.pvtValidPerSec = valid;
  g_cntSnap.nmeaPerSec = nmea;
  g_cntSnap.seq++;
  portEXIT_CRITICAL(&g_cntMux);
}
static inline void cnt_read(CntSnapshot &out)
{
  uint32_t s1, s2;
  do
  {
    s1 = g_cntSnap.seq;
    if (s1 & 1)
      continue;
    out = g_cntSnap;
    s2 = g_cntSnap.seq;
  } while (s1 != s2 || (s2 & 1));
}

// -------------------- Globals --------------------
static volatile bool g_running = true;
static UbxNavPvt g_lastPvt{};
static uint32_t lastNavPvtTick = 0;
static bool gpsLost = true;

// Counters for 1 Hz
static uint16_t ubxSeenPerSec = 0, ubxSeenLastSec = 0;
static uint16_t pvtSeenPerSec = 0, pvtSeenLastSec = 0;
static uint16_t pvtValidPerSec = 0, pvtValidLastSec = 0;
static uint16_t nmeaPerSec = 0, nmeaLastSec = 0;

// -------------------- Utility & UI state --------------------
// static inline float mmps_to_kmh(int32_t mmps) { return mmps * 0.0036f; }
static int speedCalibrationOffset = 0; // 0..5 km/h
static const char spinner[] = "/-\\|";

struct RenderState
{
  bool gpsLost;
  uint8_t fixType, numSV, calOffset;
  bool sAccBad;
  uint16_t speed_i10;
  uint8_t gpsSpin; // NEW
  uint8_t scrSpin; // NEW
};
static RenderState lastRS{true, 0xFF, 0, 0xFF, false, 0xFFFF, 0, 0};

static void drawScreen(const RenderState &rs)
{
  // Setup
  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);
  // Screen Spinner
  display.setTextSize(2);
  display.setCursor(0, 0);
  display.print(spinner[rs.scrSpin]);
  // GPS Spinner
  display.setCursor(15, 0);
  display.print(spinner[rs.gpsSpin]);
  // Offset
  display.setTextSize(1);
  display.setCursor(88, 2);
  display.print("+");
  display.setCursor(95, 2);
  display.print(rs.calOffset);
  display.setCursor(104, 2);
  display.print("kmh");

  // Sat logo
  display.drawXBitmap(30, 0, sat_logo, sat_logo_WIDTH, sat_logo_HEIGHT, 1);
  // Number of satlites
  display.setTextSize(2);
  display.setCursor(55, 0);
  if (rs.gpsLost)
    display.print("x");
  else
    display.print(rs.numSV);

  // Inaccuracy indicator
  if (rs.sAccBad)
  {
    display.setTextSize(1);
    display.setCursor(114, 55);
    display.print("x");
  }

  // Speed
  display.setTextSize(4);
  display.setCursor(0, 28);
  if (rs.gpsLost)
    display.print("LOST");
  else if (rs.fixType < 2)
    display.print("---");
  else
  {
    if (rs.speed_i10 >= 1000)
    {
      display.setCursor(0, 28);
      display.print((int)(rs.speed_i10 / 10));
    }
    else if (rs.speed_i10 >= 100)
    {
      display.setCursor(30, 28);
      display.print((int)(rs.speed_i10 / 10));
    }
    else
    {
      display.setCursor(0, 28);
      display.print(rs.speed_i10 / 10.0f, 1);
    }
  }
  display.display();
}

// -------------------- GPS task (core 1) --------------------
static void gps_task(void *)
{
  coreIdGps = xPortGetCoreID();
  Serial.printf("[gps_task] running on core %d\n", coreIdGps);
  uint32_t tRate = millis();
  while (g_running)
  {
    // UBX framer
    UbxFrame f;
    while (GPS.available())
    {
      // if (GPS.peek() == '$')
      // {
      //   // có thể có >1 câu NMEA dính nhau → cho hàm tự quét đến cuối dòng & tăng nmeaPerSec
      //   nmeaPrefilterPoll(GPS, &nmeaPerSec, 128);
      //   continue;
      // }
      uint8_t c = (uint8_t)GPS.read();
      if (FR.feed(c, f))
      {
        ubxSeenPerSec++;
        if (f.cls == 0x01 && f.id == 0x07 && f.len == sizeof(UbxNavPvt))
        {
          pvtSeenPerSec++;
          memcpy((void *)&g_lastPvt, f.payload, sizeof(UbxNavPvt));
          lastNavPvtTick = millis();
          gpsLost = false;
          g_pvtVer++;
          rt_write(g_lastPvt, gpsLost, g_pvtVer);
          if (g_lastPvt.fixType >= 2)
            pvtValidPerSec++;
        }
      }
    }

    // LOST detect
    uint32_t now = millis();
    if (now - lastNavPvtTick > 5000)
    {
      if (!gpsLost)
      {
        gpsLost = true;
        rt_write(g_lastPvt, gpsLost, g_pvtVer); // giữ nguyên version
      }
    }

    // 1 Hz counters publish
    if (now - tRate >= 1000)
    {
      tRate = now;
      ubxSeenLastSec = ubxSeenPerSec;
      ubxSeenPerSec = 0;
      pvtSeenLastSec = pvtSeenPerSec;
      pvtSeenPerSec = 0;
      pvtValidLastSec = pvtValidPerSec;
      pvtValidPerSec = 0;
      nmeaLastSec = nmeaPerSec;
      nmeaPerSec = 0;
      cnt_write(ubxSeenLastSec, pvtSeenLastSec, pvtValidLastSec, nmeaLastSec);
    }

    vTaskDelay(pdMS_TO_TICKS(1));
  }
  vTaskDelete(nullptr);
}

// -------------------- UI task (core 0) --------------------
static inline int getEffectiveCalibrationOffset(float speedKmh, int rawOffset)
{
  int eff = rawOffset;
  if (speedKmh >= 60)
    eff = rawOffset;
  else if (speedKmh >= 40)
    eff = rawOffset - 1;
  else if (speedKmh >= 20)
    eff = rawOffset - 2;
  else
    eff = rawOffset - 3;
  if (eff < 0)
    eff = 0;
  if (eff > 5)
    eff = 5;
  return eff;
}

static void ui_task(void *)
{
  coreIdUi = xPortGetCoreID();
  Serial.printf("[ui_task]  running on core %d\n", coreIdUi);
  Serial.println("====================================================");
  uint32_t lastDrawMs = 0,
           lastStatMs = 0, lastRedrawUs = 0, lastPvtVer = 0;
  uint32_t redrawCount = 0, redrawsPerSec = 0; // PATCH: new

  uint8_t gpsSpin = 0;
  RtSnapshot rt{};
  CntSnapshot cnt{};

  for (;;)
  {
    // Button
    if (digitalRead(PIN_BUTTON) == HIGH)
    {
      vTaskDelay(pdMS_TO_TICKS(200));
      if (digitalRead(PIN_BUTTON) == LOW)
        speedCalibrationOffset = (speedCalibrationOffset + 1) % 6;
    }

    // Read realtime snapshot frequently
    rt_read(rt);

    // Build render state
    RenderState rs;
    rs.gpsLost = rt.gpsLost;
    rs.fixType = rt.pvt.fixType;
    rs.numSV = rt.pvt.numSV;
    rs.calOffset = (uint8_t)speedCalibrationOffset;
    // rs.sAccBad = ((float)rt.pvt.sAcc > 0.05f * (float)rt.pvt.gSpeed);
    rs.sAccBad = ((rt.pvt.gSpeed <= (int32_t)5555) && (rt.pvt.sAcc > (int32_t)278)) || ((rt.pvt.gSpeed > (int32_t)5555) && ((float)rt.pvt.sAcc > 0.05f * (float)rt.pvt.gSpeed)); // < 20kmh --> sAcc 1kmh, > 20kmh --> sAcc > 5% gSpeed
    // if ((rt.pvt.gSpeed <= (int32_t)5555) && (rt.pvt.sAcc > (int32_t)278))
    //   rs.sAccBad == true;
    // else if ((rt.pvt.gSpeed > 5555) && ((float)rt.pvt.sAcc > 0.05f * (float)rt.pvt.gSpeed))
    //   rs.sAccBad == true;
    // else
    //   rs.sAccBad == false;
    // < 20kmh --> sAcc 1kmh, > 20kmh --> sAcc > 5% gSpeed
    rs.gpsSpin = lastRS.gpsSpin;
    if (rt.pvtVer != lastPvtVer)
    {
      rs.gpsSpin = (uint8_t)((rs.gpsSpin + 1) % 4);
    }

    float speedKmh = rt.gpsLost ? 0.0f : (rt.pvt.gSpeed * 0.0036f);
    if (speedKmh < 1.0f)
      speedKmh = 0.0f;
    int effOffset = getEffectiveCalibrationOffset(speedKmh, speedCalibrationOffset);
    float print_speed = rs.gpsLost ? 0.0f : (speedKmh + effOffset);
    rs.speed_i10 = (uint16_t)lroundf(print_speed * 10.0f);

    uint32_t now = millis();
    // Sau rt_read(rt) và build RenderState rs
    bool changed = (rt.pvtVer != lastPvtVer) ||        // NEW: có PVT mới
                   (rs.gpsLost != lastRS.gpsLost) ||   // trạng thái mất GPS đổi
                   (rs.calOffset != lastRS.calOffset); // bấm nút đổi offset

    bool needDraw = changed || (now - lastDrawMs > 200);
    if (needDraw)
    {
      uint32_t t0 = millis();
      rs.scrSpin = (uint8_t)((lastRS.scrSpin + 1) % 4);
      drawScreen(rs);
      lastRedrawUs = millis() - t0;
      lastDrawMs = now;
      lastRS = rs;
      lastPvtVer = rt.pvtVer;
      redrawCount++; // PATCH: count redraw
    }

    // 1 Hz: read and print counters
    if (now - lastStatMs >= 1000)
    {
      lastStatMs = now;
      cnt_read(cnt);
      redrawsPerSec = redrawCount; // PATCH
      redrawCount = 0;             // reset
#if DEBUG_PROFILE
#if DEBUG_CPU
      float load[2] = {0, 0};
      computeCpuLoad1s(load);
      float heapPct = 0.0f, psramPct = 0.0f;
      bool hasPsram = false;
      getMemoryUsage(heapPct, psramPct, hasPsram);
      Serial.printf("CPU load         : core0=%.2f%% core1=%.2f%%\n", load[0], load[1]);
      if (hasPsram)
        Serial.printf("Mem usage        : Heap=%.2f%%  PSRAM=%.2f%%\n", heapPct, psramPct);
      else
        Serial.printf("Mem usage        : Heap=%.2f%%\n", heapPct);
#endif
      Serial.printf("Packet/s         : %u (pps)\n", cnt.ubxPerSec + cnt.nmeaPerSec);
      Serial.printf("UBX/s            : %u (pps)\n", cnt.ubxPerSec);
      Serial.printf("PVT_seen/s       : %u (pps)\n", cnt.pvtSeenPerSec);
      Serial.printf("PVT_valid/s      : %u (pps)\n", cnt.pvtValidPerSec);
      Serial.printf("NMEA/s           : %u (pps)\n", cnt.nmeaPerSec);
      Serial.printf("redraw_ms        : %u (ms)\n", (unsigned long)lastRedrawUs);
      Serial.printf("redraw/s (FPS)   : %u (fps)\n", redrawsPerSec); // PATCH: new log
      Serial.println("----------------------------------------------");
#endif
    }

    vTaskDelay(pdMS_TO_TICKS(5));
  }
}

// -------------------- setup/loop --------------------
void setup()
{
  setCpuFrequencyMhz(240); // runtime force 240 MHz
  Serial.begin(115200);

  // Turn off radios & free memory
  WiFi.mode(WIFI_OFF);
  esp_wifi_stop();
  esp_wifi_deinit();
  btStop();
  esp_bt_controller_disable();
  esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT);
  esp_bt_controller_mem_release(ESP_BT_MODE_BLE);

  Wire.begin(21, 22);
  Wire.setClock(400000);
  Serial.printf("[ESP32] CPU frequency = %u MHz\n", getCpuFrequencyMhz());

  if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS))
  {
    Serial.println(F("[SETUP] SSD1306 allocation failed"));
    while (1)
      delay(1000);
  }
  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(4);
  display.setCursor(0, 14);
  display.print("SETUP");
  display.display();

  pinMode(PIN_BUTTON, INPUT_PULLDOWN);

  // DETECT CURRENT BAUDRATE
  Serial.println("\n[SETUP] [Auto-Baud Detect | UBX checksum or NMEA]");
  static int CURRENT_BAUD_RATE = detectGPSBaudrateWithStatus();
  if (CURRENT_BAUD_RATE > 0)
    Serial.printf("[SETUP] >>> Current GPS baudrate: %d\n", CURRENT_BAUD_RATE);
  else
    Serial.println("[SETUP] !!! Cannot detect GPS baudrate (no valid UBX/NMEA on known rates).");

  if (CURRENT_BAUD_RATE != (int)TARGET_BAUD)
  {
    display.clearDisplay();
    display.setTextColor(SSD1306_WHITE);
    display.setTextSize(2);
    display.setCursor(0, 14);
    display.print("[SETUP] Send CMD");
    display.display();
    Serial.println("[SETUP] Looks like GPS module is at factory setting. Reconfiguring...");
    GPS.begin(CURRENT_BAUD_RATE, SERIAL_8N1, PIN_RXD2, PIN_TXD2);

    auto drawAckToOLED = [&](const char *name, bool ok)
    {
      display.clearDisplay();
      display.setTextColor(SSD1306_WHITE);
      display.setTextSize(1);
      display.setCursor(0, 14);
      display.print(name);
      display.setCursor(0, 36);
      display.print(ok ? "OK" : "NOK");
      display.display();
    };

    auto sendWithAckLog = [&](const uint8_t *cmd, uint8_t cls, uint8_t id, const char *name, uint16_t timeout)
    {
      bool ok = sendUbxWithAck(cmd, cls, id, timeout);
      Serial.printf("%s: %s\n", name, ok ? "ACK OK" : "ACK FAIL/Timeout");
      drawAckToOLED(name, ok);
      delay(20);
      return ok;
    };

    // Disable NMEA on all ports; enable UBX NAV-PVT; set 10 Hz; tweak signals; set baud 115200
    sendWithAckLog(NMEA_ID_GGA_I2C_OFF, 0x06, 0x8a, "NMEA GGA I2C OFF", 1000);
    sendWithAckLog(NMEA_ID_GGA_SPI_OFF, 0x06, 0x8a, "NMEA GGA SPI OFF", 1000);
    sendWithAckLog(NMEA_ID_GGA_UART1_OFF, 0x06, 0x8a, "NMEA GGA UART1 OFF", 1000);
    sendWithAckLog(NMEA_ID_GLL_I2C_OFF, 0x06, 0x8a, "NMEA GLL I2C OFF", 1000);
    sendWithAckLog(NMEA_ID_GLL_SPI_OFF, 0x06, 0x8a, "NMEA GLL SPI OFF", 1000);
    sendWithAckLog(NMEA_ID_GLL_UART1_OFF, 0x06, 0x8a, "NMEA GLL UART1 OFF", 1000);
    sendWithAckLog(NMEA_ID_GSA_I2C_OFF, 0x06, 0x8a, "NMEA GSA I2C OFF", 1000);
    sendWithAckLog(NMEA_ID_GSA_SPI_OFF, 0x06, 0x8a, "NMEA GSA SPI OFF", 1000);
    sendWithAckLog(NMEA_ID_GSA_UART1_OFF, 0x06, 0x8a, "NMEA GSA UART1 OFF", 1000);
    sendWithAckLog(NMEA_ID_GSV_I2C_OFF, 0x06, 0x8a, "NMEA GSV I2C OFF", 1000);
    sendWithAckLog(NMEA_ID_GSV_SPI_OFF, 0x06, 0x8a, "NMEA GSV SPI OFF", 1000);
    sendWithAckLog(NMEA_ID_GSV_UART1_OFF, 0x06, 0x8a, "NMEA GSV UART1 OFF", 1000);
    sendWithAckLog(NMEA_ID_RMC_I2C_OFF, 0x06, 0x8a, "NMEA RMC I2C OFF", 1000);
    sendWithAckLog(NMEA_ID_RMC_SPI_OFF, 0x06, 0x8a, "NMEA RMC SPI OFF", 1000);
    sendWithAckLog(NMEA_ID_RMC_UART1_OFF, 0x06, 0x8a, "NMEA RMC UART1 OFF", 1000);
    sendWithAckLog(NMEA_ID_VTG_I2C_OFF, 0x06, 0x8a, "NMEA VTG I2C OFF", 1000);
    sendWithAckLog(NMEA_ID_VTG_SPI_OFF, 0x06, 0x8a, "NMEA VTG SPI OFF", 1000);
    sendWithAckLog(NMEA_ID_VTG_UART1_OFF, 0x06, 0x8a, "NMEA VTG UART1 OFF", 1000);

    sendWithAckLog(UBX_NAV_PVT_UART1_ON, 0x06, 0x8a, "UBX NAV-PVT UART1 ON", 1000);
    sendWithAckLog(CFG_NAVSPG_DYNMODEL_AUTOMOTIVE, 0x06, 0x8a, "DYNMODEL AUTOMOTIVE", 1000);
    sendWithAckLog(CFG_RATE_MEAS_10Hz, 0x06, 0x8a, "RATE 10Hz", 1000);
    sendWithAckLog(GAL_ENA_OFF, 0x06, 0x8a, "GAL ENA OFF", 1000);
    delay(1000);
    sendWithAckLog(GAL_E1_ENA_OFF, 0x06, 0x8a, "GAL E1 OFF", 1000);
    delay(1000);
    // sendWithAckLog(BDS_B1_ENA_OFF, 0x06, 0x8a, "BDS B1I OFF", 1000);
    // delay(1000);
    // sendWithAckLog(BDS_B1C_ENA, 0x06, 0x8a, "BDS B1C ON", 1000);
    // delay(1000);
    sendWithAckLog(CFG_UART1_BAUDRATE_115200, 0x06, 0x8a, "UART1 115200", 1000);

    GPS.flush();
    GPS.end();
    delay(80);
    // PATCH: verify module switched to TARGET_BAUD
    int rebaud = detectGPSBaudrateWithStatus();
    if (rebaud != (int)TARGET_BAUD)
    {
      Serial.printf("[SETUP] !!! GPS baud mismatch: detected %d, expected %u. Halting.\n",
                    rebaud, TARGET_BAUD);
      display.clearDisplay();
      display.setTextColor(SSD1306_WHITE);
      display.setTextSize(2);
      display.setCursor(0, 14);
      display.print("BAUD FAIL");
      display.setCursor(0, 36);
      display.print(rebaud);
      display.display();
      while (1)
      {
        delay(1000);
      } // halt forever
    }
  }

  GPS.end();
  delay(50);
  Serial.println(F("[SETUP] Set GPS rx buffer size to 2048 bytes"));

  GPS.setRxBufferSize(2048);
  GPS.begin(TARGET_BAUD, SERIAL_8N1, PIN_RXD2, PIN_TXD2);

  Serial.println(F("[SETUP] Setup complete. Speedometer should start now!"));
  Serial.println(F("===================================================="));
  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(4);
  display.setCursor(0, 14);
  display.print("READY");
  display.display();
  delay(300);
#if DEBUG_CPU
  esp_register_freertos_idle_hook_for_cpu(idle_hook_core0, 0);
  esp_register_freertos_idle_hook_for_cpu(idle_hook_core1, 1);
#endif

  xTaskCreatePinnedToCore(gps_task, "gps", 6144, nullptr, 9, nullptr, 1); // Core 1
  xTaskCreatePinnedToCore(ui_task, "ui", 6144, nullptr, 4, nullptr, 0);   // Core 0
}
void loop() { vTaskDelay(pdMS_TO_TICKS(1000)); }
